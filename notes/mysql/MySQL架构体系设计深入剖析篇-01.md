
# MySQL架构体系设计深入剖析篇-01

## InnoDB

### mysql内存管理
* 预分配内存空间
* 数据以页为单位加载，每次磁盘IO以页读取数据在缓存中
* 数据内外存交换

## mysql内存管理-页面淘汰
 内存尽量停留的热数据，冷数据放在磁盘中
* LRU
每页之间通过指针链接，最少使用放在尾部，最新访问放在头部，即把尾巴淘汰掉

- 思考 ：全表扫描对内存的影响 ？ 
>定义了两个LRU，new 和old ，链表大小比列5:3  
>全表扫描影响的old LRU
>
## mysql事务基础
事务特性：
- A 原子性：
- C 一致性
- I 隔离性
- D 持久性
并发问题： 
- 脏读  
- 不可重复读 
- 幻读

隔离级别
- 读未提交
- 读已提交
- 可重复读 
- 串行化

## mysql事务实现原理

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210422102222225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3ODY5MjQz,size_16,color_FFFFFF,t_70)
* MVCC
因此，一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”
快照版本， 
    * 活跃列表存放快照版本号
    * 列表中最小事务id
    * 列表中最大事务id
可见性判断
    * 创建快照的这一刻，还未提交的事务；
    * 创建快照之后创建的事务
* undo log
回滚日志   保证事务原子性   实现数据多版本



思考：为什么 count（*） 很慢
> 每一行记录都要判断对这个会话可见，因此count(*)请求In弄DB只好把数据一行一行读出来一次判断，可见的才能用于计算表的总数
* redo log 
- 意义：
    体积小，记录页的修改；  
    末尾追加，随机写变顺序写，发生改变的页不固定
记录修改
用于异常恢复
循环写文件

## mysql锁实现原理
* 锁粒度
    - 行级锁 ：作用在索引上  聚集索引和二级索引，在 InnoDB 中，行锁是通过索引实现的
    - 间隙锁 ：解决可重复读模式下的幻读问题
    - 表级锁 ：全表扫描时，可能发生表级锁
    
## 事务调优

### 1.结合业务场景，使用低级别事务隔离
我们在修改用户最后登录时间的业务场景中，这里对查询用户的登录时间没有特别严格的准确性要求，而修改用户登录信息只有用户自己登录时才会修改，不存在一个事务提交的信息被覆盖的可能。所以我们允许该业务使用最低隔离级别。

而如果是账户中的余额或积分的消费，就存在多个客户端同时消费一个账户的情况，此时我们应该选择 RR 级别来保证一旦有一个客户端在对账户进行消费，其他客户端就不可能对该账户同时进行消费了

### 2. 避免行锁升级表锁
    前面讲了，在 InnoDB 中，行锁是通过索引实现的，如果不通过索引条件检索数据，行锁将会升级到表锁。我们知道，表锁是会严重影响到整张表的操作性能的，所以我们应该避免他。
    
### 3. 控制事务的大小，减少锁定的资源量和锁定时间长度

以下业务若是在两种不同的执行顺序下，其结果都是一样的，但在事务性能方面却不一样：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210422214658625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3ODY5MjQz,size_16,color_FFFFFF,t_70)
这是因为，虽然这些操作在同一个事务，但锁的申请在不同时间，只有当其他操作都执行完，才会释放所有锁。因为扣除库存是更新操作，属于行锁，这将会影响到其他操作该数据的事务，所以我们应该尽量避免长时间地持有该锁，尽快释放该锁。

又因为先新建订单和先扣除库存都不会影响业务，所以我们可以将扣除库存操作放到最后，也就是使用执行顺序 1，以此尽量减小锁的持有时间

## mysql的sql优化

### explain

### 
* Show Profiles ;
Show Profiles 只显示最近发给服务器的 SQL 语句，默认情况下是记录最近已执行的 15 条记录，我们可以重新设置 profiling_history_size 增大该存储记录，最大值为 100

*  Show Profile for Query ID ;
获取到 Query_ID 之后，我们再通过 Show Profile for Query ID 语句，就能够查看到对应 Query_ID 的 SQL 语句在执行过程中线程的每个状态所消耗的时间了：